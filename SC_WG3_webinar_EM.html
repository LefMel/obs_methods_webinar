<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Output-based methodological approaches for substantiating freedom from infection</title>
    <meta charset="utf-8" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Output-based methodological approaches for substantiating freedom from infection
## SOUND control - Working group 3
### 2021-11-09 (updated: 2021-11-05)

---




class: inverse, center, middle

# Objectives

---
# Objectives

By the end of this presentation, you should understand:

- the main epidemiological and statistical considerations for the estimation of a probability of freedom from infection

- the principles of some of the methods used, their advantages and limitations

---
class: inverse, center, middle

# Epidemiological and methodological considerations for the estimation of freedom from infection

---
## Freedom from infection as a statistical problem

- Evidence of infection sought by testing animals from the population of interest

--

 - Testing all the animals is usually too costly `\(\rightarrow\)` sampling
 
--

 - `\(\geq 1\)` (true) positive `\(\rightarrow\)` infection is present
 
--

 - 0 test positive `\(\rightarrow\)` infection is absent OR infection is present, but no infected included in the sample

--


- Most of the time, the problem consists in **quantifying the probability that the infection is not present given that it has not been detected**

--

- The question can be formulated as: 

 - **how sure are we that the infection is truly absent given that we did not find it?** or

 - **what is the probability of a false negative surveillance outcome?**

---
class: inverse, center, middle
![](figs/black_swans_popper.jpg)

---
## Freedom from infection as a statistical problem

- Consider a large population in which 20% of animals are infected

- 10 animals of this population are tested with a perfect test

- Below is the distribution of the number of positives we would get if we could take many samples of 10 animals

![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-1-1.png)&lt;!-- --&gt;
---
## Freedom from infection as a statistical problem

- Consider a large population in which 20% of animals are infected

- 20 animals of this population are tested with a perfect test

- Below is the distribution of the number of positives we would get if we could take many samples of 20 animals

![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---
## Freedom from infection as a statistical problem

- Consider a large population in which 1% of animals are infected

- 20 animals of this population are tested with a perfect test

- Below is the distribution of the number of positives we would get if we could take many samples of 20 animals

![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---
## Freedom from infection as a statistical problem

- When testing 10 animals in a population with a prevalence of infection of 20%, there is a 10.7% chance of getting no test positive

 - The probability of a false negative surveillance outcome is:

`$$p(X = 0| n = 10, \pi = 0.2) = 0.107$$`

--

- When testing 20 animals in a population with a prevalence of infection of 20%, the probability of a false negative surveillance outcome is:

`$$p(X = 0| n = 20, \pi = 0.2) = 0.01$$`

--

- When testing 20 animals in a population with a prevalence of infection of 1%, the probability of a false negative surveillance outcome is:

`$$p(X = 0| n = 20, \pi = 0.01) = 0.818$$`

--

- What happens if the prevalence is 0?

---
## Freedom from infection as a statistical problem

- Probability of a false negative surveillance outcome `\(\nearrow\)` when:

 - sample size `\(\searrow\)`
 
 - prevalence `\(\searrow\)`
 
--

- But usually, the **true prevalence** is not known

 - We now how to estimate `\(p(X = 0|n, \pi)\)`
 
 - We would like to know `\(p(\pi = 0 | X = 0, n)\)`


---
## Freedom from infection as a statistical problem

- Chosen approach: use of a **design prevalence**

--

- Principle:

 - Assume that the disease is present at some chosen prevalence `\(\pi_t\)`, called the *design prevalence*
 
 - Make hypotheses that can be tested from this design prevalence

 `$$H_o: \pi \geq \pi_t$$`
 `$$H_A: \pi &lt; \pi_t$$`
 
--
 
 - Construct confidence intervals, estimate probabilities of error from these hypotheses

![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---
# What is a probability, **frequentist version**

- Probabilities as frequencies of events

--

- The probability of drawing an infected animal when randomly sampling from a large population is the infection prevalence
 
--

- When estimating prevalence by randomly sampling from a large population, the estimation will get closer and closer to the true prevalence as sample size increases

---
# What is a probability, **Bayesian version**

- Probabilities as hypotheses derived from evidence, knowledge or belief

--

- The probability of foot and mouth disease being introduced in Sweden cannot be estimated from past occurrences

 - Plausible values for this probability of introduction could be proposed by considering all the possible routes of introduction and adding the probabilities of occurrence of each one
 
--

- Rare / emerging events have small probabilities of occurrence that prevent the estimation of frequencies 

---
# Output-based standards

- Objective of output-based surveillance: produce outputs that are independent of the input and method of analysis used

--

- What are these outputs?

 - (Specificity of surveillance)
 
 - Sensitivity of surveillance
 
 - Probability of freedom from infection
 
 - Expected cost of error
 
 - `\(\ldots\)`

--

![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---
# Specificity of surveillance

- Probability of a negative surveillance outcome when the infection is absent (true negative):

 `$$SSp = p(O^-|D^-)$$`

 - Usually assumed to be 1 (i.e. no false positive) `\(\rightarrow\)` every positive test will be investigated until either proven to be a false positive or confirmed as a true positive
 
![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

---
# Sensitivity of surveillance

- Probability of a positive surveillance outcome when the infection is present (at the design prevalence)

 `$$SSe = p(O^+|D^+)$$`

![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

---
# Probability of freedom from infection

- Probability that the infection is absent when the outcome of surveillance is negative

  `$$P_{free} = p(D^-|O^-)$$`


![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;

- is in fact the negative predictive value

  `$$P_{free} = \frac{SSp.(1 - \pi_t)}{SSp.(1 - \pi_t) + (1-SSe) . \pi_t}$$`
  
---
# Probability of freedom from infection

- Probability that the infection is absent when the outcome of surveillance is negative

  `$$P_{free} = p(D^-|O^-)$$`


![](SC_WG3_webinar_EM_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

- since `\(SSp = 1\)`, can be written as:

  `$$P_{free} = \frac{1 - \pi_t}{1-SSe.\pi_t}$$`

---
# Expected cost of error

- Estimation of the cost of undetected infections

 `$$ECE = (1 - P_{free}) . Cost_{error}$$`
 
- Can be used to justify the total cost of surveillance

 `$$TSC = Cost_{surveillance}+(1 - P_{free}).Cost_{error}$$`

---
# Other outputs

- More recently, indicators of early detection considered, although not strictly related to infection freedom

 - Influence on the cost of error `\(\rightarrow\)` the longer the time between introduction of infection, the higher the resulting costs

![](figs/outputs.png)


---
## Impact of disease prevalence context on surveillance objectives

1. Infection is absent from area (e.g. BVDV in Scandinavian countries)
 
 - **Objective of surveillance =** prove to trading partners that it is safe to trade with you
 
 - **Level at which proof of freedom is sought =** whole area
 
--

1. Infection is still present (e.g. BVDV in France)

 - **Objective of surveillance =** identify herds / regions that are safe to trade with
 
 - **Level at which proof of freedom is sought =** herd / region

---
## Making inference


---
## Diversity in surveillance programmes


---
## Factors affecting the performance of surveillance

- Test characteristics

- Surveillance components

- Frequency of testing

---
# Test Characteristics

- Sensitivity `\(\rightarrow\)` prob of a posive test result (T) given (|) presence of infection(I)
`$$Se = p(T^+|I^+)$$`
- Specificity `\(\rightarrow\)` prob of a negative test result (T) given (|) absence of infection(I)
`$$Sp = p(T^-|I^-)$$`

---
# Surveillance components

![](figs/surveillance_components.png)

---
# Frequency of testing

![](figs/frequency_testing.png)
---
class: inverse, center, middle
# Methods for output-based surveillance

---
# Objectives of this section

- review state-of-the-art methods used for output-based surveillance

---
## Secenario tree modelling (I)

- Method to estimate probability of freedom from infection 

- (+) quantitative estimates (-) applied only in settings where infection is (assumed to be) absent

- Described in Martin et al (2007)

---
# Secenario tree modelling (II)

### Output `\(\rightarrow\)` Surveillance sensitivity

- probability of detecting a positive animal/herd if the infection in the population is above the design prevalence

`$$SSe = p(O^+|D^+)$$`

### Output `\(\rightarrow\)` Probability of freedom from infection

`$$P_{free} = p(D^-|O^-)$$`
---
## Scenario Tree modelling (III)

![](figs/scenario_tree_figure.png)

---
## Bayesian Belief Networks (I)

- Method to estimate probability of freedom from infection

- (+) Applied to complex surveillance schemes (multiple surveillance components)

- Simple application of the Bayes theorem: joint probability distirubtion for a set of variables

- Described in Hood et al (2009)

---
## Bayesian Belief Networks (II)

- Probabilistic graphical model 

- Variables `\(\rightarrow\)` nodes
- Relationshop between variables/Dependence `\(\rightarrow\)` edges/arcs

---
## Bayesian Belief Networks (III)

![](figs/bayesian_network.png)
---
## Simulation models (I)

- presence or spread of diseases and their detection with a great flexibility in terms of the range and complexity of assumptions

- Natural extensions of the scenario tree models - well suited to represent complex disease dynamic and surveillance systems 

- Described in Meyer et al (2019); Rosendal et al (2020)

---
## Simulation models (II)

![](figs/simulation_methods_new.jpg)
---
# Bayesian prevalence estimation methods

## Historical context

- Modelling the diversity of surveillance programmes in an output-based framework may result in overparameterization

- Cattle population can be considered structured in the following levels: Country / Region / Herd / Animal

---
## General approaches

### Multiple-stage cluster sampling

- random number of k herds are selected and a random sample of n animals from each herd are tested

---
# Bayesian hierarchical true prevalence estimation (I)

- (+) Assumes absence of a perfect reference test

- (+) Can be applied both in cases where infection is present or absent

- (+) Adjusts for population structure

- (+) Allows prevalence inference on the different structure levels

---
# Bayesian hierarchical true prevalence estimation (II)

![](figs/bayesian_hierarchical.png)

---
## STOC free model


---
# Plan for Grant Period 4

## Two Short Term Scientific Missions on methods

- Scenario tree modelling: apply the method on data collected from WG2

- STOC free: apply the method to another disease rathen than BVD (depends on data availability)


---
# Thank you for your attention

![](figs/sound_control.png)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
